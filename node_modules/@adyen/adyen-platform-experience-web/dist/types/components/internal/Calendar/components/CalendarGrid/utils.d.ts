type PropertyDescriptor<T = any> = {
    configurable?: boolean;
    enumerable?: boolean;
    value?: T;
    writable?: boolean;
    get?(): T | undefined;
    set?(v?: T): void;
};
type PropertyFactory = {
    <T = any>(setter?: false | ((value?: T) => T | undefined), value?: T): PropertyDescriptor<T>;
    is: (value: any) => value is PropertyDescriptor;
    isObject: (value: any) => value is Record<any, any>;
    immutable: <T = any>(value?: T) => PropertyDescriptor<T>;
    mutable: <T = any>(value?: T) => PropertyDescriptor<T>;
    restricted: () => PropertyDescriptor<undefined>;
};
export declare const property: PropertyFactory;
export declare const propsProperty: {
    <T extends Record<string, any> = {}>(props?: ({ [K in keyof T]: PropertyDescriptor<T[K]> | (T[K] extends PropertyDescriptor<infer U> ? U extends Record<string, any> ? { [K_1 in keyof U]: PropertyDescriptor<U[K_1]> | (U[K_1] extends PropertyDescriptor<infer U> ? U extends Record<string, any> ? any & Record<string, any> : U : U[K_1]); } & Record<string, any> : U : T[K]); } & Record<string, any>) | undefined, deepImmutable?: boolean): PropertyDescriptor<{ [K in keyof T]: PropertyDescriptor<T[K]> | (T[K] extends PropertyDescriptor<infer U> ? U extends Record<string, any> ? { [K_1 in keyof U]: PropertyDescriptor<U[K_1]> | (U[K_1] extends PropertyDescriptor<infer U> ? U extends Record<string, any> ? any & Record<string, any> : U : U[K_1]); } & Record<string, any> : U : T[K]); } & Record<string, any>>;
    unwrapped: <T_1 extends Record<string, any> = {}>(props?: ({ [K_2 in keyof T_1]: PropertyDescriptor<T_1[K_2]> | (T_1[K_2] extends PropertyDescriptor<infer U> ? U extends Record<string, any> ? { [K_1 in keyof U]: PropertyDescriptor<U[K_1]> | (U[K_1] extends PropertyDescriptor<infer U> ? U extends Record<string, any> ? any & Record<string, any> : U : U[K_1]); } & Record<string, any> : U : T_1[K_2]); } & Record<string, any>) | undefined, deepImmutable?: boolean) => T_1;
};
export {};
//# sourceMappingURL=utils.d.ts.map