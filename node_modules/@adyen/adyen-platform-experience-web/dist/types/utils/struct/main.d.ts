import { isPlainObject } from '../value/is';
import type { PredicateType } from '../types';
type _PlainObject<T> = PredicateType<typeof isPlainObject<T>>;
export declare const asPlainObject: <T>(value?: T | undefined, fallback?: Extract<T, import("../types").ExtractWithFallback<T, Record<any, any>>>) => Extract<T, import("../types").ExtractWithFallback<T, Record<any, any>>>;
interface _StructFrom {
    <T extends Record<any, any>, P extends object | null>(o: P, properties: {
        [K in keyof T]: TypedPropertyDescriptor<T[K]>;
    }): P extends object ? Omit<P, keyof T> & T : T;
    <P extends object | null>(o: P): P extends object ? {
        [K in keyof P]: P[K];
    } : Record<any, any>;
}
interface _Struct {
    <T extends Record<any, any>>(properties: {
        [K in keyof T]: TypedPropertyDescriptor<T[K]>;
    }): T;
    (): Record<any, any>;
}
export declare const structFrom: _StructFrom;
export declare const struct: _Struct;
export declare const withFreezeProxyHandlers: <T extends object>(handler?: ProxyHandler<T>) => Readonly<ProxyHandler<T>>;
export {};
//# sourceMappingURL=main.d.ts.map