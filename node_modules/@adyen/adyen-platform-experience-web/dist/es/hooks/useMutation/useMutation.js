import { useState as p, useRef as g, useCallback as M, useEffect as P, useMemo as _ } from "../../external/preact/hooks/dist/hooks.module.js";
import { isNumber as b, isFunction as k } from "../../utils/value/is.js";
import { ALREADY_RESOLVED_PROMISE as x } from "../../utils/async/constants.js";
import { tryResolve as a } from "../../utils/async/main.js";
import { EMPTY_OBJECT as I } from "../../utils/value/constants.js";
const u = (e) => {
  setTimeout(() => {
    throw e;
  }, 0);
};
function V({
  queryFn: e,
  options: A
}) {
  const { retry: l = !1, retryDelay: o = 1e3, onSuccess: i, onError: f, onSettled: s, shouldRetry: m } = A || I, [w, y] = p(null), [T, d] = p(null), [r, c] = p("idle"), h = g(!0), n = g(0), C = M(() => {
    y(null), d(null), c("idle"), n.current = 0;
  }, []), E = M(() => {
    n.current = 0;
  }, []), R = M(
    async (...D) => {
      try {
        c("loading"), d(null);
        const t = await (e == null ? void 0 : e(...D));
        return h.current && (y(t), c("success")), x.then(() => {
          i && a(i, t).catch(u), s && a(s, t, null).catch(u), E();
        }), t;
      } catch (t) {
        let S = 0;
        if (b(l) && (!m || m(t)) ? S = Math.max(0, Math.floor(l)) : S = 0, n.current++ < S) {
          const L = k(o) ? o(n.current) : o ?? 1e3;
          return await new Promise((O) => setTimeout(O, L)), R(...D);
        }
        throw h.current && (d(t), c("error")), x.then(() => {
          f && a(f, t).catch(u), s && a(s, void 0, t).catch(u), E();
        }), t;
      }
    },
    [e, i, s, l, m, o, E, f]
  );
  return P(() => () => {
    h.current = !1;
  }, []), _(
    () => ({
      data: w,
      error: T,
      status: r,
      isIdle: r === "idle",
      isLoading: r === "loading",
      isSuccess: r === "success",
      isError: r === "error",
      mutate: R,
      reset: C
    }),
    [w, T, r, R, C]
  );
}
export {
  V as default
};
