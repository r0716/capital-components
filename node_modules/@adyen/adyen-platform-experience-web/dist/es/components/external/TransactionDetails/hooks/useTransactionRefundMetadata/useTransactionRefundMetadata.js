import { useMemo as s } from "../../../../../external/preact/hooks/dist/hooks.module.js";
import W from "../../../../../core/Context/useCoreContext.js";
import { AlertTypeOption as A } from "../../../../internal/Alert/types.js";
import { RefundMode as p, RefundStatus as b, RefundedState as g } from "../../context/types.js";
import { checkRefundStatusCollection as j } from "./helpers.js";
import { boolOrFalse as z } from "../../../../../utils/value/bool.js";
import { isFunction as q, isUndefined as J } from "../../../../../utils/value/is.js";
import { useAuthContext as K } from "../../../../../core/Auth/context.js";
const H = ["completed", "in_progress", "failed"], Q = (t) => {
  var S, v, F;
  const { i18n: o } = W(), e = t == null ? void 0 : t.refundDetails, a = (e == null ? void 0 : e.refundMode) ?? p.FULL_AMOUNT, M = z(e == null ? void 0 : e.refundLocked), E = a !== p.NON_REFUNDABLE, c = (S = t == null ? void 0 : t.originalAmount) == null ? void 0 : S.value, f = s(() => {
    var r;
    return t ? Math.max(0, ((r = e == null ? void 0 : e.refundableAmount) == null ? void 0 : r.value) ?? 0) : 0;
  }, [e, t]), G = q(K().endpoints.initiateRefund), O = G && E && f > 0, N = ((v = e == null ? void 0 : e.refundableAmount) == null ? void 0 : v.currency) ?? (t == null ? void 0 : t.amount.currency) ?? "", C = !O || M, u = s(() => {
    var I;
    const r = ((I = t == null ? void 0 : t.refundDetails) == null ? void 0 : I.refundStatuses) ?? [];
    return (r == null ? void 0 : r.filter((n) => n.amount.value !== 0).sort((n, d) => H.includes(n.status) && H.includes(d.status) && H.indexOf(n.status) > H.indexOf(d.status) ? 0 : -1).reduce((n, d) => {
      var T;
      const l = d.status, R = ~d.amount.value + 1;
      return n != null && n[l] ? ((T = n == null ? void 0 : n[l]) == null || T.amounts.push(R), n) : { ...n, [l]: { amounts: [R], currency: d.amount.currency } };
    }, {})) ?? {};
  }, [(F = t == null ? void 0 : t.refundDetails) == null ? void 0 : F.refundStatuses]), m = s(() => {
    var I, n;
    const r = (n = (I = u.completed) == null ? void 0 : I.amounts) == null ? void 0 : n.reduce((d, l) => d + l, 0);
    return r ? Math.max(0, r ?? 0) : 0;
  }, [u]), { some: h, every: i } = s(
    () => j(({ status: r }) => r === b.COMPLETED, e == null ? void 0 : e.refundStatuses),
    [e == null ? void 0 : e.refundStatuses]
  ), $ = s(() => {
    var r;
    return f === 0 && m > 0 && i && m === c ? [{ type: A.HIGHLIGHT, label: o.get("refund.fullAmountRefunded") }] : ((r = Object.keys(u)) == null ? void 0 : r.map((n) => {
      var T, U;
      const d = n, l = (T = u == null ? void 0 : u[d]) == null ? void 0 : T.amounts.reduce((L, y, B) => {
        var D, P, x;
        const _ = (D = u == null ? void 0 : u[d]) == null ? void 0 : D.amounts.length;
        return _ > 1 && B === _ - 1 ? `${L ? `${L}` : ""} ${o.get("and")} ${o.amount(y, (P = u == null ? void 0 : u[d]) == null ? void 0 : P.currency)}` : `${L ? `${L},` : ""} ${o.amount(y, (x = u == null ? void 0 : u[d]) == null ? void 0 : x.currency)}`;
      }, ""), R = (U = u == null ? void 0 : u[d]) == null ? void 0 : U.amounts.reduce((L, y) => L + y, 0);
      switch (n) {
        case b.COMPLETED:
          return {
            type: A.HIGHLIGHT,
            label: o.get("refund.amountAlreadyRefunded", { values: { amount: l } })
          };
        case b.IN_PROGRESS:
          return R === c ? {
            type: A.HIGHLIGHT,
            label: o.get("refund.theRefundIsBeingProcessed")
          } : {
            type: A.HIGHLIGHT,
            label: o.get("refund.amountInProgress", { values: { amount: l } })
          };
        case b.FAILED:
          return R === c ? {
            type: A.WARNING,
            label: o.get("refund.fullAmountFailed")
          } : {
            type: A.WARNING,
            label: o.get("refund.amountFailed", { values: { amount: l } })
          };
        default:
          return;
      }
    })) ?? [];
  }, [f, c, o, m, u, i]), k = s(() => {
    if (f > 0) {
      const r = o.amount(f, N);
      switch (a) {
        case p.FULL_AMOUNT:
          return {
            type: A.HIGHLIGHT,
            description: o.get("refund.onlyRefundable", { values: { amount: r } })
          };
        case p.PARTIAL_AMOUNT:
          return {
            type: A.HIGHLIGHT,
            description: o.get("refund.maximumRefundable", { values: { amount: r } })
          };
        default:
          return null;
      }
    }
    return null;
  }, [o, f, N, a]), w = s(() => {
    switch (a) {
      case p.NON_REFUNDABLE:
        if (f === 0 && m > 0 && i && m === c)
          return g.FULL;
    }
    switch (a) {
      case p.PARTIAL_AMOUNT:
      case p.PARTIAL_LINE_ITEMS:
        if (f > 0 && h && m > 0 && !J(c) && m < c)
          return g.PARTIAL;
    }
    return g.INDETERMINATE;
  }, [f, m, a, c, h, i]);
  return {
    refundableAmount: f,
    // the maximum amount still available for refund
    refundable: E,
    // whether the refund mode of the payment allows for refund
    refundableAmountLabel: k,
    refundAvailable: O,
    // whether a refund can be initiated for the payment
    refundAuthorization: G,
    // whether the authenticated user has sufficient permission to initiate refunds
    refundCurrency: N,
    // the payment currency for any initiated refund
    refundDisabled: C,
    // whether refund action for the payment is disabled (refund view should be prevented)
    refundedAmount: m,
    // the total amount already refunded
    refundedState: w,
    // whether the payment is yet to be, partially or fully refunded
    refundStatuses: $,
    //the refund statuses
    refundLocked: M,
    // whether refund action for the payment is temporarily locked
    refundMode: a
    // the refund mode of the payment
  };
}, re = Q;
export {
  re as default,
  Q as useTransactionRefundMetadata
};
