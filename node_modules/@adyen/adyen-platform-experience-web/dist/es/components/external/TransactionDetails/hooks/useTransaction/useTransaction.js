import q from "./transactionNavigator/createDuplexTransactionNavigator.js";
import { useState as d, useRef as e, useMemo as w, useCallback as I, useEffect as m } from "../../../../../external/preact/hooks/dist/hooks.module.js";
import { useFetch as O } from "../../../../../hooks/useFetch.js";
import { useAuthContext as P } from "../../../../../core/Auth/context.js";
import { EMPTY_OBJECT as N } from "../../../../../utils/value/constants.js";
const R = (c) => {
  const [i, y] = d(c), [t, r] = d(c.id), [E, b] = d(performance.now()), { getTransaction: a } = P().endpoints, h = e(q()), x = h.current, u = e(!1), l = e(!1), T = e(c), p = e(t), A = w(() => !!a && !!t && u.current, [t, a]), C = I(
    () => a(N, {
      path: { transactionId: t }
    }),
    [t, a]
  ), {
    data: o,
    error: g,
    isFetching: s
  } = O({
    fetchOptions: { enabled: A },
    queryFn: C
  }), M = I(() => r(void 0), []);
  return m(() => {
    t || r(i.id);
  }, [t, i]), m(() => {
    var v;
    const n = h.current, f = T.current;
    return f.category === "Refund" && (n.reset(f.id, (v = f.refundMetadata) == null ? void 0 : v.originalPaymentId), n.onNavigation = ({ to: F }) => {
      u.current = !0, b(performance.now()), F && r(F);
    }), () => {
      u.current = !1, n.onNavigation = null, n.reset();
    };
  }, []), m(() => {
    if (l.current !== s && !(l.current = s))
      if (!o || g)
        r(p.current);
      else {
        const n = T.current;
        y(() => ({
          ...o.id === n.id ? n : N,
          ...o
        })), p.current = t;
      }
  }, [o, g, s, t, E]), { fetchingTransaction: s, refreshTransaction: M, transaction: i, transactionNavigator: x };
}, L = R;
export {
  L as default,
  R as useTransaction
};
