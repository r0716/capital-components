var h = Object.defineProperty;
var p = (r, t, o) => t in r ? h(r, t, { enumerable: !0, configurable: !0, writable: !0, value: o }) : r[t] = o;
var e = (r, t, o) => (p(r, typeof t != "symbol" ? t + "" : t, o), o);
import { render as n } from "../../external/preact/dist/preact.module.js";
import { uuid as u } from "../../utils/random/uuid.js";
import { isString as a } from "../../utils/value/is.js";
var s;
class i {
  constructor(t) {
    e(this, "_component");
    e(this, "_node", null);
    e(this, "_id", `${(s = this.constructor) == null ? void 0 : s.type}-${u()}`);
    e(this, "defaultProps", {});
    e(this, "props");
    e(this, "state", {});
    this.props = this.formatProps({ ...this == null ? void 0 : this.defaultProps, ...t }), this.props.core.registerComponent(this);
  }
  /**
   * Executed during creation of any element.
   * Gives a chance to any component to format the props we're receiving.
   */
  formatProps(t) {
    return t;
  }
  /**
   * Executed on the `data` getter.
   * Returns the component data necessary for making a request
   */
  formatData() {
    return {};
  }
  setState(t) {
    this.state = { ...this.state, ...t };
  }
  /**
   * Returns the component data ready to submit to the Checkout API
   * Note: this does not ensure validity, check isValid first
   */
  get data() {
    return {
      ...this.formatData(),
      clientStateDataIndicator: !0
    };
  }
  render() {
    throw new Error("Component cannot be rendered.");
  }
  mount(t) {
    const o = a(t) ? document.querySelector(t) : t;
    if (!o)
      throw new Error("Component could not mount. Root node was not found.");
    return this._node && this.unmount(), this._node = o, this._component = this.render(), n(this._component, o), this;
  }
  /**
   * Updates props, resets the internal state and remounts the element.
   * @param props - props to update
   * @returns this - the element instance
   */
  update(t) {
    return this.props = this.formatProps({ ...this.props, ...t }), this._component = this.render(), this._node && n(this._component, this._node), this;
  }
  /**
   * Unmounts an element and mounts it again on the same node i.e. allows mount w/o having to pass a node.
   * Should be "private" & undocumented (although being a public function is useful for testing).
   * Left in for legacy reasons
   */
  remount(t) {
    if (!this._node)
      throw new Error("Component is not mounted.");
    const o = t || this.render();
    return n(o, this._node), this;
  }
  /**
   * Unmounts an element from the DOM
   */
  unmount() {
    return this._node && n(null, this._node), this;
  }
  /**
   * Unmounts an element and removes it from the parent instance
   * For "destroy" type cleanup - when you don't intend to use the component again
   */
  remove() {
    this.unmount(), this.props.core.remove(this);
  }
}
e(i, "type");
const _ = i;
export {
  _ as default
};
