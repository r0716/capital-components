import { jsx as t } from "../../../../../external/preact/jsx-runtime/dist/jsxRuntime.module.js";
import { useCallback as g, useMemo as f, useEffect as w } from "../../../../../external/preact/hooks/dist/hooks.module.js";
import M from "../../../../../hooks/useBalanceAccountSelection.js";
import x from "../../../../../hooks/useDefaultOverviewFilterParams.js";
import q from "../../../../internal/FilterBar/filters/DateFilter/DateFilter.js";
import { LIMIT_OPTIONS as K, DEFAULT_PAGE_LIMIT as j } from "../../../../internal/Pagination/constants.js";
import { FilterParam as o } from "../../../../types.js";
import { ReportsTable as k } from "../ReportsTable/ReportsTable.js";
import { BASE_CLASS as v, EARLIEST_PAYOUT_SINCE_DATE as z } from "./constants.js";
import "./ReportsOverview.scss.js";
import B from "../../../../internal/Pagination/hooks/useCursorPaginatedRecords.js";
import G, { useFilterBarState as H, FilterBarMobileSwitch as Y } from "../../../../internal/FilterBar/FilterBar.js";
import J from "../../../../internal/FormFields/Select/BalanceAccountSelector/BalanceAccountSelector.js";
import { useAuthContext as Q } from "../../../../../core/Auth/context.js";
import { isFunction as V } from "../../../../../utils/value/is.js";
import { Header as W } from "../../../../internal/Header/Header.js";
const Er = ({
  onFiltersChanged: i,
  balanceAccounts: a,
  allowLimitSelection: l,
  preferredLimit: u = j,
  isLoadingBalanceAccount: c,
  onContactSupport: E,
  hideTitle: T
}) => {
  const { getReports: s } = Q().endpoints, { activeBalanceAccount: r, balanceAccountSelectionOptions: S, onBalanceAccountSelection: F } = M(a), { defaultParams: e, nowTimestamp: C, refreshNowTimestamp: m } = x("reports", r), I = g(
    async (n, U) => s({ signal: U, errorLevel: "error" }, {
      query: {
        ...n,
        type: "payout",
        createdSince: n[o.CREATED_SINCE] ?? e.current.defaultFilterParams[o.CREATED_SINCE],
        createdUntil: n[o.CREATED_UNTIL] ?? e.current.defaultFilterParams[o.CREATED_UNTIL],
        balanceAccountId: (r == null ? void 0 : r.id) ?? ""
      }
    }),
    [r == null ? void 0 : r.id, e, s]
  ), p = H(), _ = f(() => V(i) ? i : void 0, [i]), A = f(() => l ? K : void 0, [l]), { canResetFilters: P, error: D, fetching: L, filters: d, limit: O, limitOptions: R, records: h, resetFilters: X, updateFilters: N, updateLimit: b, ...y } = B({
    fetchRecords: I,
    dataField: "data",
    filterParams: e.current.defaultFilterParams,
    initialFiltersSameAsDefault: !0,
    onFiltersChanged: _,
    preferredLimit: u,
    preferredLimitOptions: A,
    enabled: !!(r != null && r.id) && !!s
  });
  return w(() => {
    m();
  }, [d, m]), /* @__PURE__ */ t("div", { className: v, children: [
    /* @__PURE__ */ t(W, { hideTitle: T, titleKey: "reportsTitle", subtitleKey: "reportsNotice", children: /* @__PURE__ */ t(Y, { ...p }) }),
    /* @__PURE__ */ t(G, { ...p, children: [
      /* @__PURE__ */ t(
        J,
        {
          activeBalanceAccount: r,
          balanceAccountSelectionOptions: S,
          onBalanceAccountSelection: F
        }
      ),
      /* @__PURE__ */ t(
        q,
        {
          canResetFilters: P,
          defaultParams: e,
          filters: d,
          nowTimestamp: C,
          refreshNowTimestamp: m,
          sinceDate: z,
          timezone: "UTC",
          updateFilters: N
        }
      )
    ] }),
    /* @__PURE__ */ t(
      k,
      {
        balanceAccountId: r == null ? void 0 : r.id,
        loading: L || c || !a || !r,
        data: h,
        showPagination: !0,
        limit: O,
        limitOptions: R,
        onContactSupport: E,
        onLimitSelection: b,
        error: D,
        ...y
      }
    )
  ] });
};
export {
  Er as ReportsOverview
};
