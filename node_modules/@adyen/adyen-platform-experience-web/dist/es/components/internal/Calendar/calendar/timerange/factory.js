import { createRangeTimestampsConfigRestampingContext as W, parseRangeTimestamp as a, isRangeTimestampsConfigWithoutOffsets as Y, isRangeTimestampsConfigWithFromOffsets as b, getRangeTimestampsConfigParameterUnwrapper as E } from "./utils.js";
import H from "../../../../../core/Localization/datetime/restamper/restamper.js";
import { asPlainObject as d, struct as R } from "../../../../../utils/struct/main.js";
import { getter as c } from "../../../../../utils/struct/property.js";
import { EMPTY_OBJECT as u } from "../../../../../utils/value/constants.js";
const $ = (C = u, D = u) => {
  const s = d(C), h = d(D);
  return () => {
    const i = H(), l = c(() => o), T = c(() => i.tz.current), f = R({
      now: l,
      timezone: T,
      ...W(i)
    }), m = E(s, f);
    let { from: n, to: r, now: o } = u;
    const g = (p) => {
      o = a(p ?? Date.now()) ?? o;
      t: {
        if (Y(s)) {
          n = a(m(s.from)) ?? o, r = a(m(s.to)) ?? o;
          break t;
        }
        let t, e, w;
        (w = b(s)) ? (t = new Date(n = a(m(s.from)) ?? o), e = 1) : (t = new Date(r = a(m(s.to)) ?? o), e = -1), t = new Date(f.timezoneToSystem(t));
        const [F = 0, O = 0, x = 0, M = 0, S = 0, _ = 0, P = 0] = m(s.offsets);
        t.setFullYear(t.getFullYear() + F * e, t.getMonth() + O * e, t.getDate() + x * e), t.setHours(
          t.getHours() + M * e,
          t.getMinutes() + S * e,
          t.getSeconds() + _ * e,
          t.getMilliseconds() + P * e
        );
        const z = a(f.systemToTimezone(t)) ?? o;
        w ? r = z : n = z;
      }
      n > r && ([n, r] = [r, n]);
    }, y = (p) => {
      const t = i.tz, e = t.current;
      i.tz = p, t.current !== e && g(o);
    };
    return g(), R({
      ...h,
      from: c(() => n),
      now: { ...l, set: g },
      timezone: { ...T, set: y },
      to: c(() => r)
    });
  };
}, U = $;
export {
  U as default
};
