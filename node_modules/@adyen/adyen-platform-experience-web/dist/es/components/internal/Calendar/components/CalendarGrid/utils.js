import { isPlainObject as b } from "../../../../../utils/value/is.js";
import { EMPTY_OBJECT as u } from "../../../../../utils/value/constants.js";
import { struct as a, structFrom as l } from "../../../../../utils/struct/main.js";
import { enumerable as m } from "../../../../../utils/struct/property.js";
import { boolOrTrue as O } from "../../../../../utils/value/bool.js";
const n = (() => {
  const c = (e) => Object.freeze(
    l(u, Object.fromEntries(Object.entries(e).map(([r, t]) => [r, { value: t }])))
  ), i = (e) => {
    try {
      return Object.getPrototypeOf(e) === u;
    } catch {
      return !1;
    }
  }, o = (e, r) => {
    if (!e)
      return c(m(r, O(e)));
    let t = r;
    return c({
      enumerable: !0,
      get: () => t,
      set: (s) => {
        t = e(s);
      }
    });
  };
  return Object.defineProperties(o, {
    is: { value: i },
    isObject: { value: b },
    immutable: { value: (e) => o(!1, e) },
    mutable: { value: (e) => o(void 0, e) },
    restricted: { value: () => o(!1) }
  });
})(), g = (() => {
  const c = (o = {}, e = !1) => {
    const r = a();
    for (const [t, s] of Object.entries(o)) {
      try {
        const p = n.is(s), f = n.isObject(s);
        if (p || f) {
          Object.defineProperty(r, t, p ? s : c(s, e));
          continue;
        } else if (e) {
          Object.defineProperty(r, t, n.immutable(s));
          continue;
        }
      } catch {
      }
      r[t] = s;
    }
    return n((t = {}) => Object.assign(r, t), r);
  };
  return Object.defineProperties(c, {
    unwrapped: { value: (o = {}, e = !1) => {
      const r = c(o, e);
      return a({ P: r }).P;
    } }
  });
})();
export {
  n as property,
  g as propsProperty
};
