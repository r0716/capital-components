var _t = Object.defineProperty;
var bt = (a, s, i) => s in a ? _t(a, s, { enumerable: !0, configurable: !0, writable: !0, value: i }) : a[s] = i;
var st = (a, s, i) => (bt(a, typeof s != "symbol" ? s + "" : s, i), i), ot = (a, s, i) => {
  if (!s.has(a))
    throw TypeError("Cannot " + i);
};
var t = (a, s, i) => (ot(a, s, "read from private field"), i ? i.call(a) : s.get(a)), r = (a, s, i) => {
  if (s.has(a))
    throw TypeError("Cannot add the same private member more than once");
  s instanceof WeakSet ? s.add(a) : s.set(a, i);
}, e = (a, s, i, h) => (ot(a, s, "write to private field"), h ? h.call(a, i) : s.set(a, i), i);
var K = (a, s, i, h) => ({
  set _(o) {
    e(a, s, o, i);
  },
  get _() {
    return t(a, s, h);
  }
}), n = (a, s, i) => (ot(a, s, "access private method"), i);
import { resolveTimeFrameBlockSize as xt, downsizeTimeFrame as gt } from "../common/utils.js";
import Lt, { UNBOUNDED_SLICE as ft } from "../../timeslice/index.js";
import { computeTimestampOffset as Ut } from "../../utils.js";
import { FIRST_WEEK_DAYS as Nt, DAY_MS as pt, SHIFT_FRAME as ct, SHIFT_PERIOD as wt, SHIFT_BLOCK as zt, CURSOR_NEXT_BLOCK as Wt, CURSOR_PREV_BLOCK as Mt, CURSOR_LINE_END as Ht, CURSOR_LINE_START as Kt, CURSOR_BLOCK_END as vt, CURSOR_BLOCK_START as Yt, CURSOR_DOWNWARD as Vt, CURSOR_UPWARD as Xt, CURSOR_FORWARD as jt, CURSOR_BACKWARD as qt, SELECTION_COLLAPSE as Gt, SELECTION_NEAREST as Ot, SELECTION_FARTHEST as Ft, SELECTION_TO as kt, SELECTION_FROM as Tt } from "../../constants.js";
import Jt from "../common/flags.js";
import { BASE_LOCALE as Pt } from "../../../../../../core/Localization/datetime/restamper/constants.js";
import It from "../../../../../../primitives/time/today/main.js";
import { createIndexed as it } from "../../../../../../primitives/auxiliary/indexed/main.js";
import { isUndefined as et, isNullish as D, isBoolean as Bt, isFunction as Qt } from "../../../../../../utils/value/is.js";
import { isInfinity as lt, clamp as ut, mid as Zt, isBitSafeInteger as St, mod as $t } from "../../../../../../utils/value/number.js";
import { enumerable as I } from "../../../../../../utils/struct/property.js";
import { struct as ts } from "../../../../../../utils/struct/main.js";
var N, g, Y, V, X, j, k, F, B, w, z, W, _, S, q, l, f, c, M, E, b, H, T, G, J, R, C, P, Q, rt, ht, nt, Ct, at, Rt, y, L, mt, yt, p, O, x, v, Z, dt;
const U = class U {
  constructor() {
    r(this, nt);
    r(this, at);
    r(this, y);
    r(this, mt);
    r(this, p);
    r(this, x);
    r(this, Z);
    r(this, g, 0);
    r(this, Y, void 0);
    r(this, V, void 0);
    r(this, X, -1);
    r(this, j, -1);
    r(this, k, void 0);
    r(this, F, void 0);
    r(this, B, void 0);
    r(this, w, !1);
    r(this, z, void 0);
    r(this, W, 0);
    r(this, _, []);
    r(this, S, t(U, N));
    r(this, q, 12);
    r(this, l, void 0);
    r(this, f, void 0);
    r(this, c, 1);
    r(this, M, void 0);
    r(this, E, void 0);
    r(this, b, void 0);
    r(this, H, It());
    r(this, T, void 0);
    r(this, G, -1 / 0);
    r(this, J, 1 / 0);
    r(this, R, -1 / 0);
    r(this, C, 1 / 0);
    r(this, P, 1 / 0);
    r(this, Q, 0);
    st(this, "daysInWeek", 0);
    st(this, "origin");
    st(this, "originTimestamp");
    r(this, rt, it(() => this.daysInWeek, this.getDayOfWeekAtIndex.bind(this)));
    r(this, ht, it(() => t(this, c), n(this, mt, yt).bind(this)));
  }
  get fromTimestamp() {
    return t(this, G);
  }
  get toTimestamp() {
    return t(this, J);
  }
  get numberOfBlocks() {
    return t(this, P);
  }
  get blankSelection() {
    return t(this, l) === t(this, f) && et(t(this, f));
  }
  get cursor() {
    return t(this, k) ?? -1;
  }
  get daysOfWeek() {
    return t(this, rt);
  }
  get dynamicBlockHeight() {
    return t(this, w);
  }
  set dynamicBlockHeight(s) {
    D(s) ? e(this, w, !!s) : Bt(s) && e(this, w, s);
  }
  set effect(s) {
    D(s) ? e(this, z, void 0) : Qt(s) && e(this, z, s);
  }
  get firstWeekDay() {
    return t(this, W);
  }
  set firstWeekDay(s) {
    if (D(s))
      this.firstWeekDay = 0;
    else if (!Nt.includes(s) || t(this, W) === e(this, W, s))
      return;
  }
  get frameBlocks() {
    return t(this, ht);
  }
  get isAtEnd() {
    return !lt(t(this, C)) && t(this, C) === t(this, c) - 1;
  }
  get isAtStart() {
    return !lt(t(this, R)) && t(this, R) === 0;
  }
  get locale() {
    return t(this, S);
  }
  set locale(s) {
    const i = t(this, S);
    if (D(s))
      e(this, S, t(U, N));
    else if (typeof Intl < "u")
      try {
        e(this, S, new Intl.Locale(s).toString());
      } catch {
        e(this, S, t(U, N));
      }
    t(this, S) !== i && this.refreshFrame(!0);
  }
  get selectionStart() {
    return t(this, l);
  }
  get selectionEnd() {
    return t(this, f);
  }
  get size() {
    return t(this, c);
  }
  set size(s) {
    const i = Math.min(!D(s) && xt(s) || 1, t(this, q));
    t(this, c) !== e(this, c, i) && (n(this, Z, dt).call(this), this.refreshFrame());
  }
  get timeslice() {
    return t(this, E);
  }
  set timeslice(s) {
    if (s === t(this, M) || D(s) && t(this, M) === ft)
      return;
    const { from: i, to: h, timezone: o } = e(this, M, s ?? ft);
    e(this, E, Lt(i, h)), this.timezone = o;
  }
  get timezone() {
    return t(this, b);
  }
  set timezone(s) {
    t(this, E).timezone = s, e(this, b, t(this, E).timezone), e(this, H, It(t(this, b))), t(this, T) && (t(this, T).call(this), e(this, T, t(this, H).subscribe(this.refreshFrame.bind(this, !0)))), n(this, nt, Ct).call(this);
  }
  set trackCurrentDay(s) {
    Bt(s) ? s && !t(this, T) ? e(this, T, t(this, H).subscribe(this.refreshFrame.bind(this, !0))) : !s && t(this, T) && (t(this, T).call(this), e(this, T, void 0)) : D(s) && (this.trackCurrentDay = !1);
  }
  get units() {
    return t(this, Q);
  }
  initialize() {
    this.timeslice = ft;
  }
  refreshFrame(s = !1) {
    var i;
    if (t(this, _).length = 0, !(et(t(this, F)) || s)) {
      const h = this.getFrameBlockAtIndex(t(this, g)), { from: o, to: m } = h.inner, [d] = n(this, y, L).call(this, this.getTimestampAtIndex(o + t(this, F)), !1);
      e(this, F, this.getUnitsOffsetForTimestamp(this.getTimestampAtIndex(o), d));
      const u = o + t(this, F), A = ut(o, u, m);
      if (A > u)
        return e(this, F, this.getUnitsForFrameBlockAtIndex(--K(this, g)._) + u - A), t(this, g) >= 0 ? this.refreshFrame() : (e(this, g, t(this, c) - 1), this.shiftFrameByOffset(-1, ct));
      if (A < u)
        return e(this, F, u - A - 1), ++K(this, g)._ < t(this, c) ? this.refreshFrame() : (e(this, g, 0), this.shiftFrameByOffset(1, ct));
      e(this, Y, o), e(this, V, m), e(this, B, n(this, y, L).call(this, this.getTimestampAtIndex(u), !1)[0]), e(this, F, this.getCursorBlockOriginTimestampOffset(t(this, B))), e(this, k, o + t(this, F));
      const $ = t(this, g) > 0 ? this.getFrameBlockAtIndex(0) : h, tt = t(this, g) < t(this, c) - 1 ? this.getFrameBlockAtIndex(t(this, c) - 1) : h;
      e(this, X, $.inner.from), e(this, j, tt.inner.to), e(this, Q, tt.outer.to + 1);
    }
    this.withCurrentDayTimestamp(), (i = t(this, z)) == null || i.call(this);
  }
  shiftFrameByOffset(s, i) {
    if (s && St(s))
      switch (i) {
        case zt:
          return n(this, x, v).call(this, s);
        case wt:
          return n(this, x, v).call(this, s * 12);
        case ct:
        default:
          return n(this, x, v).call(this, s * t(this, c));
      }
  }
  shiftFrameCursor(s) {
    switch (s) {
      case qt:
        return n(this, p, O).call(this, -1);
      case jt:
        return n(this, p, O).call(this, 1);
      case Xt:
        return n(this, p, O).call(this, -this.rowspan);
      case Vt:
        return n(this, p, O).call(this, this.rowspan);
      case Yt:
        return n(this, p, O).call(this, t(this, Y) - t(this, k));
      case vt:
        return n(this, p, O).call(this, t(this, V) - t(this, k));
      case Kt:
        return n(this, p, O).call(this, -(t(this, k) % this.rowspan));
      case Ht:
        return n(this, p, O).call(this, this.rowspan - (t(this, k) % this.rowspan + 1));
      case Mt:
        return n(this, p, O).call(this, -this.getUnitsForFrameBlockAtIndex((t(this, g) ?? 0) - 1));
      case Wt:
        return n(this, p, O).call(this, this.getUnitsForFrameBlockAtIndex(t(this, g) ?? 0));
    }
    if (!(s < 0) && s >= t(this, X) && s <= t(this, j))
      return n(this, p, O).call(this, s - t(this, k));
  }
  shiftFrameToTimestamp(s) {
    e(this, B, this.originTimestamp = n(this, y, L).call(this, s, !1).reduce((i, h) => i + h)), e(this, F, this.getCursorBlockOriginTimestampOffset(t(this, B))), this.reoriginate(), [K(this, R)._, K(this, C)._] = this.getEdgeBlockOffsetsFromOrigin(), n(this, Z, dt).call(this), this.refreshFrame(), n(this, p, O).call(this, this.getUnitsOffsetForTimestamp(this.getTimestampAtIndex(t(this, k)), t(this, B)));
  }
  clearSelection() {
    this.blankSelection || (e(this, l, e(this, f, void 0)), this.refreshFrame(!0));
  }
  updateSelection(s, i) {
    const h = t(this, l), o = t(this, f), m = n(this, y, L).call(this, s, !1).reduce((d, u) => d + u);
    switch (i === Ft && (m <= h ? i = kt : m >= o && (i = Tt)), i) {
      case Tt:
        e(this, l, m), e(this, f, Math.max(t(this, l), o ?? m));
        break;
      case kt:
        e(this, f, m), e(this, l, Math.min(h ?? m, t(this, f)));
        break;
      case Ft:
      case Ot: {
        let d = Math.abs(m - (h ?? m)), u = Math.abs(m - (o ?? m));
        i === Ot && ([d, u] = [u, d]), d > u ? e(this, l, m) : e(this, f, m);
        break;
      }
      case Gt:
      default:
        e(this, l, e(this, f, m));
        break;
    }
    (t(this, l) !== h || t(this, f) !== o) && this.refreshFrame(!0);
  }
};
N = new WeakMap(), g = new WeakMap(), Y = new WeakMap(), V = new WeakMap(), X = new WeakMap(), j = new WeakMap(), k = new WeakMap(), F = new WeakMap(), B = new WeakMap(), w = new WeakMap(), z = new WeakMap(), W = new WeakMap(), _ = new WeakMap(), S = new WeakMap(), q = new WeakMap(), l = new WeakMap(), f = new WeakMap(), c = new WeakMap(), M = new WeakMap(), E = new WeakMap(), b = new WeakMap(), H = new WeakMap(), T = new WeakMap(), G = new WeakMap(), J = new WeakMap(), R = new WeakMap(), C = new WeakMap(), P = new WeakMap(), Q = new WeakMap(), rt = new WeakMap(), ht = new WeakMap(), nt = new WeakSet(), Ct = function() {
  const { from: s, to: i, span: h, offsets: o } = t(this, E);
  e(this, G, s - o.from), e(this, J, i - o.to), e(this, P, h);
  const m = et(t(this, l)) ? t(this, l) : Math.max(t(this, l), s), d = et(t(this, f)) ? t(this, f) : Math.min(t(this, f), i);
  m === t(this, l) || d === t(this, f) ? (e(this, l, m), e(this, f, d)) : e(this, l, e(this, f, void 0)), this.reslice(), e(this, q, gt(12, this.numberOfBlocks)), e(this, c, gt(t(this, c), this.numberOfBlocks)), this.shiftFrameToTimestamp(t(this, B));
}, at = new WeakSet(), Rt = function(s) {
  return ut(t(this, R), s || 0, t(this, C) - t(this, c) + 1);
}, y = new WeakSet(), L = function(s, i = !0) {
  let h = new Date(s).getTime();
  if (isNaN(h))
    return n(this, y, L).call(this, Date.now());
  const { from: o, to: m } = t(this, E), d = ut(o, h, m);
  d !== h && i ? (h = Zt(o, m), (isNaN(h) || lt(h)) && (h = d)) : h = d;
  const u = Ut(h, t(this, b));
  return [h - u, u];
}, mt = new WeakSet(), yt = function(s) {
  if (St(s) && s >= 0 && s < t(this, c)) {
    if (!t(this, _)[s]) {
      const i = this.getFrameBlockAtIndex(s);
      if (!i)
        return;
      const [h, o] = this.getFormattedDataForFrameBlock(i[i.inner.from][0] + pt / 2), m = i.outer.from;
      t(this, _)[s] = it(
        {
          datetime: I(o),
          label: I(h),
          length: I(Math.ceil(i.outer.units / this.rowspan)),
          month: I(i.month),
          year: I(i.year)
        },
        (d) => {
          const u = d * this.rowspan;
          return it(this.rowspan, (A) => {
            const [$, tt] = i[A + u], [At, Dt] = this.getFormattedDataForBlockCell($ + pt / 2);
            return ts({
              datetime: I(Dt),
              flags: I(Jt(tt)),
              index: I(m + A + u),
              label: I(At),
              timestamp: I($)
            });
          });
        }
      );
    }
    return t(this, _)[s];
  }
}, p = new WeakSet(), O = function(s) {
  s !== 0 && (e(this, F, t(this, F) + s), this.refreshFrame());
}, x = new WeakSet(), v = function(s) {
  const i = n(this, at, Rt).call(this, s);
  i && (this.shiftOrigin(i), e(this, R, t(this, R) - i), e(this, C, t(this, C) - i), e(this, g, $t(t(this, g) - i, t(this, c))), this.refreshFrame());
}, Z = new WeakSet(), dt = function() {
  const s = t(this, c) - 1, i = Math.min(s - this.origin % t(this, c), t(this, C)) - s;
  i && n(this, x, v).call(this, i);
}, r(U, N, Pt);
let Et = U;
export {
  Et as default
};
