import { useRef as f, useMemo as m } from "../../../../external/preact/hooks/dist/hooks.module.js";
import { DEFAULT_PAGE_LIMIT as a } from "../constants.js";
import { getClampedPageLimit as l } from "../utils.js";
import { mid as d } from "../../../../utils/value/number.js";
import { isNumber as p } from "../../../../utils/value/is.js";
const h = (r, o) => {
  const n = r.length - 1;
  if (n < 0)
    return o;
  if (o <= r[0])
    return r[0];
  if (o >= r[n])
    return r[n];
  let i = 0, c = 0, s = n;
  for (; ; ) {
    const e = r[i = d(c, s)];
    if (c > s || o === e)
      return e;
    o > e ? c = i + 1 : s = i - 1;
  }
}, b = ({
  preferredLimit: r = a,
  preferredLimitOptions: o
}) => {
  const n = f(), i = f(), c = m(() => {
    try {
      const e = /* @__PURE__ */ new Set();
      for (const t of o) {
        const u = l(t);
        u > 0 && e.add(u);
      }
      return Object.freeze([...e].sort((t, u) => t - u));
    } catch {
    }
  }, [o]);
  return { limit: m(() => {
    let e = l(r) || a;
    e:
      try {
        if (n.current === c)
          break e;
        const t = new Set(n.current = c);
        if (t.size === 0) {
          n.current = void 0;
          break e;
        }
        if (i.current !== e)
          t: {
            if (t.size === t.add(e).size)
              break t;
            if (t.delete(e), t.size === t.add(i.current).size) {
              if (p(i.current)) {
                e = i.current;
                break t;
              }
            } else
              t.delete(i.current);
            e = h(n.current, e);
          }
      } catch {
      }
    return i.current = e;
  }, [c, r]), limitOptions: c };
}, q = b;
export {
  q as default,
  h as getNearestFromSortedUniqueNums
};
