import { useRef as P, useCallback as p, useState as T, useMemo as s, useEffect as j } from "../../../../external/preact/hooks/dist/hooks.module.js";
import F from "../../../../hooks/useBooleanState.js";
import H from "../../../../hooks/useMounted.js";
import { getClampedPageLimit as J } from "../utils.js";
import { noop as K } from "../../../../utils/common.js";
const L = (V, l, M) => {
  const u = P(), c = P(), h = P(), r = P(), i = H(
    p(() => {
      var o;
      (o = u.current) == null || o.abort(), u.current = void 0;
    }, [])
  ), [t, x] = T(r.current), [g, $] = F(!1), e = s(() => J(M), [M]), { getPageCount: v, getPageParams: A, resetPageCount: y, updatePagination: I } = V, n = s(() => l ? (o) => {
    var z;
    if (!(e && Number.isInteger(o)))
      return;
    const f = v(), a = o < 0 ? o + f + 1 : o;
    a > 0 && (f ? a <= f : a === 1) && ((z = u.current) == null || z.abort(), u.current = new AbortController(), i.current && (((r.current = a) > 1 || f) && x(r.current), (async () => {
      const { signal: S } = u.current, D = { ...A(a, e), limit: e, page: a };
      try {
        const d = await l(D, S);
        if (!d || !i.current)
          return;
        const { size: b, ...G } = d;
        I(a, e, G), c.current = r.current && Math.max(r.current, c.current || -1 / 0), r.current && r.current === c.current && (h.current = b), r.current === 1 && b > 0 && x(r.current), r.current = void 0, $(!0);
      } catch (d) {
        if (S.aborted)
          return;
        console.error(d);
      }
    })()));
  } : K, [e, l]), R = p(() => {
    t && n(Math.min(t + 1, v()));
  }, [n, t]), q = p(() => {
    t && n(Math.max(t - 1, 1));
  }, [n, t]), m = s(() => v() || t || void 0, [n, g]), w = s(() => !!(t && m) && t < m, [t, m]), E = s(() => !!t && t > 1, [t]), C = s(
    () => c.current ? (c.current - 1) * e + (h.current || 0) : 0,
    [n, g]
  ), N = s(() => e && Math.min(e, C || 1 / 0) % e, [e, C]), B = p(() => {
    y(), c.current = h.current = r.current = void 0, i.current && x(r.current);
  }, [y]);
  return j(() => {
    i.current && g && $(!1);
  }, [g]), { goto: n, hasNext: w, hasPrev: E, limit: e, next: R, page: t, pages: m, pageSize: N, prev: q, resetPagination: B, size: C };
}, Z = L;
export {
  Z as default
};
