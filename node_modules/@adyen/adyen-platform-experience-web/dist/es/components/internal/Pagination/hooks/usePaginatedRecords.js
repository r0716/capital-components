import { useState as R, useRef as y, useMemo as D, useCallback as L, useEffect as M } from "../../../../external/preact/hooks/dist/hooks.module.js";
import K from "./usePageLimit.js";
import Q from "./useCursorPagination.js";
import W from "./useOffsetPagination.js";
import Z from "./usePaginatedRecordsFilters.js";
import z from "../../../../hooks/useBooleanState.js";
import ee from "../../../../hooks/useMounted.js";
import { PaginationType as te, PageNeighbour as N } from "../types.js";
import { EMPTY_OBJECT as re } from "../../../../utils/value/constants.js";
import { boolOrFalse as b } from "../../../../utils/value/bool.js";
const se = ["hasNext", "hasPrevious"], w = (e) => {
  const t = Object.getOwnPropertyNames(e);
  return !se.some((r) => t.includes(r));
}, oe = (e, t = "data") => {
  const r = e[t];
  if (w(e)) {
    const n = Object.fromEntries(
      Object.entries(e._links).map(([s, o]) => [s, o.cursor])
    );
    return { records: r, paginationData: n };
  }
  throw new TypeError("MALFORMED_PAGINATED_DATA");
}, ae = (e, t = "data") => {
  const r = e[t];
  if (!w(e)) {
    const { hasNext: n, hasPrevious: s } = e, o = {
      [N.NEXT]: b(n),
      [N.PREV]: b(s)
    };
    return { records: r, paginationData: o };
  }
  throw new TypeError("MALFORMED_PAGINATED_DATA");
}, ne = ({
  dataField: e = "data",
  fetchRecords: t,
  filterParams: r = re,
  initialFiltersSameAsDefault: n = !0,
  initialize: s,
  onFiltersChanged: o,
  pagination: F,
  preferredLimit: _,
  preferredLimitOptions: $,
  enabled: E
}) => {
  const [j, v] = R([]), [x, p] = z(!0), [I, O] = R(), [S, k] = R(_), A = ee(), f = y(!0), m = y(1), T = Z(r, n), { limit: P, limitOptions: q } = K({ preferredLimit: S, preferredLimitOptions: $ }), { defaultFilters: ie, filters: a, updateFilters: B, ...C } = T, [G, J] = D(
    () => F === te.CURSOR ? [oe, Q] : [ae, W],
    []
  ), U = L((g) => k(g), []), { goto: d, page: V, pages: X, resetPagination: l, ...Y } = J(
    L(
      async ({ page: g, ...H }, c) => {
        try {
          if (O(void 0), m.current = g, !A.current || p(!0))
            return;
          const u = await t({ ...H, ...a }, c), { records: i, paginationData: h } = G(u, e);
          return f.current && (s == null || s([i, h], T), f.current = !1), A.current && (v(i), p(!1)), { ...h, size: i == null ? void 0 : i.length };
        } catch (u) {
          if (c != null && c.aborted)
            return;
          p(!1), O(u), console.error(u);
        }
      },
      [t, a, P]
    ),
    P
  );
  return D(() => {
    f.current = !0;
  }, [r]), D(() => {
    l(), m.current = 1;
  }, [a, P, l]), M(() => {
    E && d(m.current);
  }, [d, E]), M(() => {
    o == null || o(a);
  }, [a]), { error: I, fetching: x, filters: a, goto: d, limitOptions: q, page: V, pages: X, records: j, updateFilters: B, updateLimit: U, ...C, ...Y };
}, Ee = ne;
export {
  Ee as default
};
