import { jsx as S } from "../../../../../external/preact/jsx-runtime/dist/jsxRuntime.module.js";
import B from "../../../../../hooks/useTimezoneAwareDateFormatting.js";
import { useState as C, useCallback as M, useMemo as T, useEffect as E, useRef as L } from "../../../../../external/preact/hooks/dist/hooks.module.js";
import { BASE_LOCALE as x } from "../../../../../core/Localization/datetime/restamper/constants.js";
import k from "../../../../../core/Context/useCoreContext.js";
import { DateRangeFilterParam as b } from "./types.js";
import "./DateFilterCore.scss.js";
import z from "../BaseFilter/BaseFilter.js";
import I from "../../../DatePicker/DatePicker.js";
import { EMPTY_OBJECT as V } from "../../../../../utils/value/constants.js";
import { CommitAction as p } from "../../../../../hooks/useCommitAction/types.js";
const _ = {
  month: "short",
  day: "numeric",
  year: "numeric"
}, v = (s, e, n, o) => {
  const t = n && e(n), r = o && e(o);
  if (t && r)
    return `${t} - ${r}`;
  if (t)
    return s.get("filter.date.since", { values: { date: t } });
  if (r)
    return s.get("filter.date.until", { values: { date: r } });
}, i = (s) => {
  try {
    return new Date(s || "").toISOString();
  } catch {
    return "";
  }
}, Y = (() => {
  const s = ({
    editAction: e,
    from: n,
    to: o,
    now: t,
    onChange: r,
    onValueUpdated: F,
    showTimezoneInfo: w,
    selectedPresetOption: f,
    timeRangePresetOptions: c,
    timezone: D,
    sinceDate: m,
    untilDate: y
  }) => {
    const { i18n: O } = k(), { fullDateFormat: d } = B(D), [g, R] = C(f), u = T(() => [new Date(n), new Date(o)], [n, o]), a = L(), P = M(
      (l, h) => {
        F(v(O, d, i(l), i(h)));
      },
      [O, d, F]
    );
    return E(() => {
      var l, h, A;
      switch (e) {
        case p.APPLY:
          r({
            selectedPresetOption: g,
            [b.FROM]: i((l = a.current) == null ? void 0 : l.from),
            [b.TO]: i((h = a.current) == null ? void 0 : h.to)
          });
          break;
        case p.CLEAR:
          (A = a.current) == null || A.clear(), r();
      }
    }, [e, r, g]), /* @__PURE__ */ S(
      I,
      {
        ref: a,
        now: t,
        originDate: u,
        onHighlight: P,
        onPresetOptionSelected: R,
        selectedPresetOption: f,
        timeRangePresetOptions: c,
        timezone: D,
        showTimezoneInfo: w,
        sinceDate: i(m),
        untilDate: i(y)
      }
    );
  };
  return (e) => /* @__PURE__ */ S(s, { ...e });
})(), $ = (s, e, n) => s.formatRange(e, n);
function U({
  title: s,
  from: e,
  to: n,
  selectedPresetOption: o,
  ...t
}) {
  const { i18n: r } = k(), { fullDateFormat: F } = B(t.timezone), [w, f] = C(), [c, D] = C(), [m, y] = C(), O = M(
    (u) => {
      const { from: a, to: P, selectedPresetOption: l } = u ?? V;
      try {
        f(w ?? l), D(i(c ?? a)), y(i(m ?? P));
      } finally {
        t.onChange({ from: a, to: P, selectedPresetOption: l });
      }
    },
    [w, c, m, t]
  ), d = T(() => r.get("rangePreset.custom"), [r]), g = T(() => {
    const u = { ..._, timeZone: t.timezone };
    let a = new Intl.DateTimeFormat(x, u);
    try {
      a = new Intl.DateTimeFormat(r.locale, u);
    } catch {
    }
    return a;
  }, [r, t.timezone]);
  E(() => f(o), [o]), E(() => D(i(e || Date.now())), [e]), E(() => y(i(n || Date.now())), [n]);
  const R = T(() => o === d && c && m ? $(g, new Date(c), new Date(m)) : o ?? t.label, [d, g, c, m, o, t.label]);
  return /* @__PURE__ */ S(
    z,
    {
      ...t,
      from: e,
      to: n,
      type: "date",
      label: R,
      onChange: O,
      render: Y,
      selectedPresetOption: o,
      value: v(r, F, e, n),
      withContentPadding: !1
    }
  );
}
export {
  U as default
};
