var _ = Object.defineProperty;
var h = (i, e, t) => e in i ? _(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var s = (i, e, t) => (h(i, typeof e != "symbol" ? e + "" : e, t), t);
import { EVT_SESSION_EXPIRED as n, EVT_SESSION_REFRESHING_START as E, EVT_SESSION_REFRESHING_END as o, EVT_SESSION_REFRESHED as S, EVT_SESSION_READY as a, ERR_SESSION_HTTP_UNAVAILABLE as f, ERR_SESSION_EXPIRED as m } from "./constants.js";
import { INTERNAL_EVT_SESSION_DEADLINE as N, INTERNAL_EVT_SESSION_REFRESHING_START as c, INTERNAL_EVT_SESSION_REFRESHING_END as R, INTERNAL_EVT_SESSION_READY as p } from "./internal/constants.js";
import { createSessionAutofresher as I } from "./internal/autofresher.js";
import { createSessionDeadline as d } from "./internal/deadline.js";
import { createSessionRefresher as T } from "./internal/refresher.js";
import { createEventEmitter as l } from "../../reactive/eventEmitter/main.js";
import { isFunction as u } from "../../../utils/value/is.js";
import { noop as A } from "../../../utils/common.js";
class x {
  constructor(e) {
    s(this, "_session");
    s(this, "_autofresh");
    s(this, "_deadline");
    s(this, "_refresher");
    s(this, "_eventEmitter", l());
    this._specification = e, this._deadline = d(this._eventEmitter, this._specification), this._refresher = T(this._eventEmitter, this._specification), this._autofresh = I(this._refresher), this._deadline.on(N, () => this._eventEmitter.emit(n)), this._refresher.on(c, () => this._eventEmitter.emit(E)), this._refresher.on(R, () => this._eventEmitter.emit(o)), this._refresher.on(p, () => {
      this._session = this._refresher.session, this._deadline.refresh(this._session).finally(() => this._eventEmitter.emit(S)), this._eventEmitter.emit(a);
    }), this.http = this._sessionHttp.bind(this), this.on = this._eventEmitter.on, this.refresh = this._refresher.refresh;
  }
  get isExpired() {
    return this._deadline.elapsed;
  }
  get refreshing() {
    return this._refresher.refreshing;
  }
  _assertSessionHttp(e) {
    if (!u(e))
      throw f;
  }
  async _sessionHttp(e, ...t) {
    for (this._autofresh(!0); ; )
      try {
        await this._refresher.promise.catch(A);
        const { signal: r } = this._deadline;
        return await (e == null ? void 0 : e(this._session, r, ...t)), this._assertSessionHttp(this._specification.http), await this._specification.http(this._session, r, ...t);
      } catch (r) {
        if (r !== m)
          throw r;
        if (this._refresher.pending)
          continue;
        this._deadline.elapse();
      }
  }
}
export {
  x as SessionContext,
  x as default
};
