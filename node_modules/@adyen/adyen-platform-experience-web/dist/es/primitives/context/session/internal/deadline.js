import { INTERNAL_EVT_SESSION_DEADLINE as v } from "./constants.js";
import { createAbortable as y } from "../../../async/abortable/main.js";
import { createEventEmitter as A } from "../../../reactive/eventEmitter/main.js";
import { createPromisor as g } from "../../../async/promisor/main.js";
import { parseDate as S } from "../../../../utils/datetime/main.js";
import { isAbortSignal as D, abortSignalForAny as I, abortedSignal as N } from "../../../../utils/abort/main.js";
import w from "../../../time/clock/main.js";
import { isWatchlistUnsubscribeToken as F } from "../../../reactive/watchlist/main.js";
import { tryResolve as L } from "../../../../utils/async/main.js";
import { noop as T } from "../../../../utils/common.js";
import { struct as k } from "../../../../utils/struct/main.js";
import { enumerable as c, getter as u } from "../../../../utils/struct/property.js";
import { isFunction as P } from "../../../../utils/value/is.js";
const O = (R, b) => {
  let r, i = 1 / 0, p, o;
  const n = y(), _ = A(), m = () => {
    r == null || r.removeEventListener("abort", m), i = 1 / 0, o == null || o(), n.refresh(), _.emit(v);
  }, E = g(async (t, a) => {
    p = t;
    const f = await L(() => {
      const e = b.deadline;
      return P(e) ? e.call(b, a, t) : e;
    }).catch(T);
    if (p !== t)
      return;
    const d = (Array.isArray(f) ? f : [f]).filter((e) => e || e === 0);
    if (d.length > 0) {
      let e = !1, s = /* @__PURE__ */ new Set();
      for (const l of d)
        if (D(l)) {
          if (e = l.aborted)
            break;
          s.add(l);
        } else if (i = Math.min(i, S(l) ?? 1 / 0), e = i <= Date.now())
          break;
      e || (e = s.size < 1 && !Number.isFinite(i)), e ? r ?? (r = N()) : (r = I([...s, n.signal]), r.addEventListener("abort", m), h()), d.length = 0, s.clear();
    } else
      r = void 0;
  }), h = () => {
    if (!Number.isFinite(i))
      return;
    let t = w.subscribe((a) => {
      if (F(a))
        return m();
      a.now >= i && n.abort();
    });
    o = () => {
      t == null || t(), t = o = void 0;
    };
  };
  return k({
    elapse: c(n.abort),
    elapsed: u(() => r && r.aborted),
    on: c(_.on),
    refresh: c(E.bind(void 0)),
    signal: u(() => n.signal)
  });
};
export {
  O as createSessionDeadline,
  O as default
};
