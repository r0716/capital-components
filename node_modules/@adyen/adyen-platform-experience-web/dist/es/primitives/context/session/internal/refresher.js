import { INTERNAL_EVT_SESSION_REFRESHING_START as A, INTERNAL_EVT_SESSION_READY as y, INTERNAL_EVT_SESSION_REFRESHING_END as O } from "./constants.js";
import { EVT_SESSION_EXPIRED as T, ERR_SESSION_REFRESH_ABORTED as u, ERR_SESSION_INVALID as d, ERR_SESSION_FACTORY_UNAVAILABLE as F } from "../constants.js";
import { createEventEmitter as L } from "../../../reactive/eventEmitter/main.js";
import { createPromisor as P } from "../../../async/promisor/main.js";
import { ALREADY_RESOLVED_PROMISE as c } from "../../../../utils/async/constants.js";
import { struct as l } from "../../../../utils/struct/main.js";
import { enumerable as s, getter as n } from "../../../../utils/struct/property.js";
import { isAbortSignal as w, abortSignalForAny as D } from "../../../../utils/abort/main.js";
import { tryResolve as V } from "../../../../utils/async/main.js";
import { isFunction as b } from "../../../../utils/value/is.js";
const X = (R, t) => {
  let _ = !1, i, o, S = !0, f;
  const a = Symbol("<next_session>"), E = L();
  function N(e) {
    var r;
    try {
      (r = t.assert) == null || r.call(t, e);
    } catch {
      throw d;
    }
  }
  function h(e) {
    if (!b(e))
      throw F;
  }
  const m = P((e, r) => {
    if (!o)
      o = e;
    else
      return I(w(r) ? D([r, e]) : e);
  }), I = async (e) => {
    let r = a;
    try {
      _ = !1, o = e, S && await (i ?? (i = (async () => {
        await c, S = !1, E.emit(A);
      })())), h(t.onRefresh), r = await V(() => t.onRefresh(f, e)).finally(() => {
        if (e.aborted)
          throw u;
      });
    } finally {
      if (o === e)
        try {
          r !== a && (N(r), f = r, E.emit(y));
        } finally {
          i = void 0, S = !0, E.emit(O);
        }
    }
  };
  return R.on(T, () => _ = !i), m(), l({
    context: s(
      l({
        emitter: s(R),
        specification: s(t)
      })
    ),
    on: s(E.on),
    pending: n(() => _),
    promise: n(() => m.promise),
    refresh: s(m.bind(void 0)),
    refreshing: n(() => !!i),
    session: n(() => f),
    signal: n(() => o)
  });
};
export {
  X as createSessionRefresher,
  X as default
};
