import { unwrap as d, assertReflexAction as v } from "./helpers.js";
import { UnknownRefError as x } from "./errors.js";
import { REF as w } from "./constants.js";
import { struct as m } from "../../../utils/struct/main.js";
import { enumerable as p } from "../../../utils/struct/property.js";
import { isFunction as z } from "../../../utils/value/is.js";
import { sameValue as k } from "../../../utils/value/compare.js";
const A = (() => {
  const u = (n, s) => {
    const r = n.get(s);
    if (!r)
      throw new x();
    return r;
  }, b = (n, s, r) => {
    let o, e;
    const t = d(s);
    try {
      o = u(n, t);
    } catch {
      v(r);
    }
    if (o)
      [, e] = o;
    else {
      const f = z(t), g = f ? (c) => {
        t(i = c);
      } : (c) => {
        t && (t.current = c, i = t.current);
      }, l = (c) => {
        if (e.size === 0)
          return;
        const a = i;
        if (g(c), !k(i, a))
          for (const [_] of e)
            _(i, a);
      };
      let i = f ? null : t.current;
      n.set(t, o = [l, e = /* @__PURE__ */ new Map()]), Object.defineProperties(l, {
        [w]: { value: t },
        actions: {
          value: m({
            get: { value: e.get.bind(e) },
            size: { get: () => e.size }
          })
        },
        current: {
          get: () => i,
          set: f ? void 0 : l
        }
      });
    }
    return r && e.set(r, 1 + (e.get(r) || 0)), o[0];
  }, R = (n, s, r) => {
    const o = d(s), [, e] = u(n, o), t = e.get(r) || 0;
    t === 1 ? e.delete(r) : t > 1 && e.set(r, t - 1), e.size === 0 && o && n.delete(o);
  };
  return () => {
    const n = /* @__PURE__ */ new WeakMap();
    return m({
      bind: p(b.bind(void 0, n)),
      unbind: p(R.bind(void 0, n))
    });
  };
})(), I = A();
export {
  I as $globalReflexRegister,
  A as createReflexRegister,
  I as default
};
