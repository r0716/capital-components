import { getRequestObject as h, getResponseContentType as g, getResponseDownloadFilename as p, getErrorType as y, isAdyenErrorResponse as w, handleFetchError as C } from "./utils.js";
import { API_VERSION as R } from "./constants.js";
import { normalizeLoadingContext as b, normalizeUrl as E } from "../utils.js";
const c = (r, o) => {
  try {
    r == null || r(o);
  } catch {
    throw o;
  }
};
async function T(r) {
  const { errorLevel: o, loadingContext: i = "", path: u } = r, d = h(r), s = new URL(`${b(i)}${R}${E(u)}`);
  return r.params && r.params.forEach((n, t) => {
    const e = decodeURIComponent(n);
    e && s.searchParams.append(t, e);
  }), (async () => {
    let n = !1;
    const t = { level: o };
    try {
      const e = await fetch(s, d);
      if (e.ok) {
        if (e.status === 204)
          return null;
        try {
          switch (g(e)) {
            case "application/json":
              return await e.json();
            default:
              const m = await e.blob(), f = p(e);
              return { blob: m, filename: f };
          }
        } catch (l) {
          throw n = !0, l;
        }
      }
      t.type = y(e.status);
      const a = await e.json();
      t.message = r.errorMessage || `Service at ${s} not available`, t.errorCode = String(a.status), t.requestId = a == null ? void 0 : a.requestId, w(a) && (t.message = a.detail, t.errorCode = a.errorCode, t.status = a.status), c(r.errorHandler, t);
    } catch (e) {
      if (n)
        throw c(r.errorHandler, e), e;
      c(r.errorHandler, e), t.message = r.errorMessage || `Call to ${s} failed. Error: ${e}`;
    }
    C(t);
  })();
}
export {
  T as http
};
