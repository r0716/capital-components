var U = Object.defineProperty;
var b = (r, t, e) => t in r ? U(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var R = (r, t, e) => (b(r, typeof t != "symbol" ? t + "" : t, e), e), z = (r, t, e) => {
  if (!t.has(r))
    throw TypeError("Cannot " + e);
};
var s = (r, t, e) => (z(r, t, "read from private field"), e ? e.call(r) : t.get(r)), o = (r, t, e) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, e);
}, a = (r, t, e, i) => (z(r, t, "write to private field"), i ? i.call(r, e) : t.set(r, e), e);
var C = (r, t, e) => (z(r, t, "access private method"), e);
import { FALLBACK_LOCALE as E, DEFAULT_TRANSLATIONS as j, getLocalesFromTranslationSourcesRecord as x, DEFAULT_DATETIME_FORMAT as I, SUPPORTED_LOCALES as M } from "./constants/localization.js";
import { en_US as _ } from "../../translations/index.js";
import { getLocalisedAmount as W } from "./amount/amount-util.js";
import { createTranslationsLoader as $, getLocalizationProxyDescriptors as k } from "./localization-utils.js";
import { toTwoLetterCode as w, formatCustomTranslations as q, getTranslation as F } from "./utils.js";
import { createWatchlist as v } from "../../primitives/reactive/watchlist/main.js";
import B from "./datetime/restamper/restamper.js";
import { isNullish as N, isUndefined as K, isNull as V } from "../../utils/value/is.js";
import { ALREADY_RESOLVED_PROMISE as Y } from "../../utils/async/constants.js";
import { struct as Z } from "../../utils/struct/main.js";
import { noop as G } from "../../utils/common.js";
var h, g, u, T, f, p, c, A, l, m, d, L, D, S;
class ht {
  constructor(t = E, e) {
    o(this, D);
    o(this, h, E);
    o(this, g, w(s(this, h)));
    o(this, u, [E]);
    o(this, T, s(this, u));
    o(this, f, void 0);
    o(this, p, j);
    o(this, c, $.call(this));
    o(this, A, Y);
    o(this, l, void 0);
    o(this, m, void 0);
    o(this, d, v({ timestamp: () => performance.now() }));
    o(this, L, B());
    R(this, "watch", s(this, d).subscribe.bind(void 0));
    R(this, "i18n", Z(k.call(this)));
    R(this, "preferredTranslations");
    this.watch(G), this.preferredTranslations = Object.freeze(
      (e == null ? void 0 : e.reduce((i, n) => ({ ...i, ...n }), _)) ?? { ..._ }
    ), a(this, u, x(this.preferredTranslations)), this.locale = t;
  }
  get customTranslations() {
    return s(this, f) ?? {};
  }
  set customTranslations(t) {
    let e, i = [...s(this, u)];
    if (!N(t)) {
      e = q(t, M);
      const n = Object.keys(e);
      i = [...i, ...n].sort().filter((y, O, P) => P.indexOf(y) === O);
    }
    s(this, c).supportedLocales = i, C(this, D, S).call(this, e);
  }
  get languageCode() {
    return s(this, g);
  }
  get lastRefreshTimestamp() {
    return s(this, d).snapshot.timestamp;
  }
  get locale() {
    return s(this, h);
  }
  set locale(t) {
    if (N(t))
      this.locale = E;
    else {
      if (s(this, c).locale = t, s(this, h) === s(this, c).locale)
        return;
      C(this, D, S).call(this, s(this, f));
    }
  }
  get ready() {
    return s(this, A);
  }
  get supportedLocales() {
    return s(this, T);
  }
  get timezone() {
    return s(this, L).tz.current;
  }
  set timezone(t) {
    s(this, L).tz = t;
  }
  /**
   * Returns a translated string from a key in the current {@link Localization.locale}
   * @param key - Translation key
   * @param options - Translation options
   * @returns Translated string
   */
  get(t, e) {
    const i = F(s(this, p), t, e);
    return V(i) ? t : i;
  }
  /**
   * Returns a boolean that checks if the translation key exists in the current {@link Localization.locale}
   * @param key - Translation key
   * @param options - Translation options
   * @returns boolean
   */
  has(t, e) {
    return !!F(s(this, p), t, e);
  }
  /**
   * Returns a localized string for an amount
   * @param amount - Amount to be converted
   * @param currencyCode - Currency code of the amount
   * @param options - Options for String.prototype.toLocaleString
   */
  amount(t, e, i) {
    const { hideCurrency: n, ...y } = i || {}, O = W(t, s(this, h), e, n, {
      ...y,
      currencyDisplay: "symbol",
      signDisplay: "never"
    });
    return t < 0 ? `- ${O}` : O;
  }
  /**
   * Returns a localized string for a date
   * @param date - Date to be localized
   * @param options - Options for {@link Date.toLocaleDateString}
   */
  date(t, e = {}) {
    const i = { ...I, timeZone: s(this, L).tz.current, ...e };
    return new Date(t).toLocaleDateString(s(this, h), i);
  }
  /**
   * Returns a localized string for a full date
   * @param date - Date to be localized
   */
  fullDate(t) {
    return this.date(t, {
      month: "short",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: !1
    });
  }
}
h = new WeakMap(), g = new WeakMap(), u = new WeakMap(), T = new WeakMap(), f = new WeakMap(), p = new WeakMap(), c = new WeakMap(), A = new WeakMap(), l = new WeakMap(), m = new WeakMap(), d = new WeakMap(), L = new WeakMap(), D = new WeakSet(), S = function(t) {
  K(s(this, m)) && a(this, A, new Promise((n) => {
    a(this, m, () => {
      n(s(this, l)), a(this, l, a(this, m, void 0));
    });
  }));
  const e = () => {
    var n;
    s(this, l) === i && ((n = s(this, m)) == null || n.call(this));
  }, i = a(this, l, (async () => {
    a(this, p, await s(this, c).load(t)), a(this, h, s(this, c).locale), a(this, T, Object.freeze(s(this, c).supportedLocales)), a(this, f, t), a(this, g, w(s(this, h))), s(this, d).requestNotification();
  })());
  i.then(e).catch((n) => {
    e(), console.error(n);
  });
};
export {
  ht as default
};
