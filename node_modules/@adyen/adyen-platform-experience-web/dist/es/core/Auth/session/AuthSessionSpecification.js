var l = Object.defineProperty;
var f = (i, t, r) => t in i ? l(i, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : i[t] = r;
var a = (i, t, r) => (f(i, typeof t != "symbol" ? t + "" : t, r), r);
import { http as u } from "../../Http/http.js";
import { ErrorTypes as m } from "../../Http/utils.js";
import { AUTO_REFRESH as A, MAX_AGE_MS as d } from "./constants.js";
import { isPlainObject as E, isString as h, isUndefined as _ } from "../../../utils/value/is.js";
import { ERR_SESSION_EXPIRED as S } from "../../../primitives/context/session/constants.js";
import { enumerable as c } from "../../../utils/struct/property.js";
import { isAbortSignal as H, abortSignalForAny as O } from "../../../utils/abort/main.js";
class R {
  constructor(t) {
    a(this, "assert", (t) => {
      if (E(t)) {
        const r = h(t.id) ? t.id.trim() : void 0, e = h(t.token) ? t.token.trim() : void 0;
        if (r && e)
          return;
      }
      throw void 0;
    });
    a(this, "deadline", (t) => {
      const r = [];
      let e, s;
      try {
        ({ iat: e, exp: s } = JSON.parse(atob(t == null ? void 0 : t.token.split(".")[1]))), r.push(s);
      } catch {
        e = Date.now();
      }
      if (!_(d)) {
        const n = new Date(e);
        r.push(n.setMilliseconds(n.getMilliseconds() + d));
      }
      return r;
    });
    a(this, "http", async (t, r, e) => {
      const { headers: s, signal: n, ...p } = e;
      try {
        const o = {
          ...p,
          headers: {
            ...s,
            ...t && { Authorization: `Bearer ${t.token}` }
          },
          errorHandler: this._errorHandler,
          signal: H(n) ? O([r, n]) : r
        };
        return await u(o);
      } catch (o) {
        throw (o == null ? void 0 : o.type) === m.EXPIRED_TOKEN ? S : o;
      }
    });
    this.onSessionCreate = t, this._errorHandler = this._errorHandler.bind(this), Object.defineProperties(this, {
      autoRefresh: c(A),
      onRefresh: c((r, e) => this.onSessionCreate(e))
    });
  }
  _errorHandler(t) {
    try {
      this.errorHandler && this.errorHandler(t);
    } catch {
    }
    throw t;
  }
}
const y = R;
export {
  R as AuthSessionSpecification,
  y as default
};
