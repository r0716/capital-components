var P = Object.defineProperty;
var u = (s, t, r) => t in s ? P(s, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : s[t] = r;
var h = (s, t, r) => (u(s, typeof t != "symbol" ? t + "" : t, r), r);
import { SETUP_ENDPOINT_PATH as l } from "./constants.js";
import { parseSearchParams as d } from "../../Http/utils.js";
import { EMPTY_OBJECT as f } from "../../../utils/value/constants.js";
import { createPromisor as y } from "../../../primitives/async/promisor/main.js";
import { struct as x, withFreezeProxyHandlers as E, asPlainObject as b } from "../../../utils/struct/main.js";
import { isPlainObject as g, isUndefined as v } from "../../../utils/value/is.js";
import { isAbortSignal as O, abortSignalForAny as S } from "../../../utils/abort/main.js";
import { noop as c } from "../../../utils/common.js";
class k {
  constructor(t) {
    h(this, "_endpoints", f);
    h(this, "_revokeEndpointsProxy", c);
    h(this, "_beforeHttp", async () => {
      await this._refreshPromisor.promise.catch(c);
    });
    h(this, "_refreshPromisor", y((t, r) => {
      const e = O(r) ? S([r, t]) : t;
      return this._fetchSetupEndpoint(e);
    }));
    this._session = t;
    let r;
    this.refresh = (e) => (this._refreshPromisor(e).catch(c), r ?? (r = this._refreshPromisor.promise.finally(() => r = void 0).then(({ endpoints: i }) => {
      this._resetEndpoints(), { proxy: this._endpoints, revoke: this._revokeEndpointsProxy } = this._getEndpointsProxy(i);
    })));
  }
  get endpoints() {
    return this._endpoints;
  }
  _fetchSetupEndpoint(t) {
    return this._session.http(null, {
      method: "POST",
      path: l,
      errorLevel: "fatal",
      loadingContext: this.loadingContext,
      signal: t
    });
  }
  _getEndpointsProxy(t) {
    const r = new Set(Object.keys(t)), e = x();
    return Proxy.revocable(
      f,
      E({
        get: (i, o, m) => r.has(o) ? (e[o] ?? (e[o] = (() => {
          const { method: n = "GET", url: a } = t[o];
          if (!v(a || void 0))
            return (..._) => {
              const p = this._getHttpOptions(n, a, ..._);
              return this._session.http(this._beforeHttp, p);
            };
        })()), e[o]) : Reflect.get(i, o, m)
      })
    );
  }
  _getHttpOptions(t, r, ...e) {
    const { loadingContext: i } = this, [o, m] = e, { path: n, query: a } = b(m), _ = a && d(a);
    if (g(n))
      for (const p of Object.keys(n))
        r = r.replace(`{${p}}`, n[p]);
    return { loadingContext: i, ...o, method: t, params: _, path: r };
  }
  _resetEndpoints() {
    this._revokeEndpointsProxy(), this._revokeEndpointsProxy = c, this._endpoints = f;
  }
}
const U = k;
export {
  k as AuthSetupContext,
  U as default
};
