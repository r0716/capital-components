var a = Object.defineProperty;
var _ = (i, s, t) => s in i ? a(i, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[s] = t;
var e = (i, s, t) => (_(i, typeof s != "symbol" ? s + "" : s, t), t);
import f from "./AuthSetupContext.js";
import c from "./AuthSessionSpecification.js";
import { createErrorContainer as l } from "../../../primitives/auxiliary/errorContainer/main.js";
import { SessionContext as S } from "../../../primitives/context/session/SessionContext.js";
import { createPromisor as p } from "../../../primitives/async/promisor/main.js";
import { createWatchlist as u } from "../../../primitives/reactive/watchlist/main.js";
import { EVT_SESSION_EXPIRED as m, EVT_SESSION_READY as C, ERR_SESSION_REFRESH_ABORTED as d } from "../../../primitives/context/session/constants.js";
import { boolOrTrue as x, boolOrFalse as E } from "../../../utils/value/bool.js";
import { isFunction as g } from "../../../utils/value/is.js";
class y {
  constructor() {
    e(this, "_canSkipSessionRefresh", !1);
    e(this, "_refreshPromisorSignal");
    e(this, "_sessionIsFrozen", !1);
    e(this, "_errorContainer", l());
    e(this, "_specification", new c());
    e(this, "_sessionContext", new S(this._specification));
    e(this, "_setupContext", new f(this._sessionContext));
    e(this, "_refreshPromisor", p(async (s, t = !1) => {
      let r = !this._refreshPromisorSignal, n = this._refreshPromisorSignal === (this._refreshPromisorSignal = s);
      const o = E(t) && this._canSkipSessionRefresh;
      r && (r = !1, this._errorContainer.reset(), this._onAuthStateChanged());
      try {
        await (o ? this._setupContext : this._sessionContext).refresh(s).finally(() => n = this._refreshPromisorSignal === s);
      } catch (h) {
        if (!n)
          return;
        !s.aborted && (o || h !== d) && this._errorContainer.set(h), r = !o;
      } finally {
        (r || o && n) && (this._refreshPromisorSignal = void 0, this._onAuthStateChanged());
      }
    }));
    e(this, "_watchlist", u({
      endpoints: () => this._setupContext.endpoints,
      hasError: () => this._errorContainer.hasError,
      isExpired: () => this._sessionContext.isExpired,
      isFrozen: () => this._sessionIsFrozen,
      refreshing: () => !!this._refreshPromisorSignal
    }));
    e(this, "freeze", () => {
      this._sessionIsFrozen = !0, this._watchlist.on.resume = void 0, this._watchlist.cancelSubscriptions();
    });
    e(this, "http", this._sessionContext.http.bind(this._sessionContext, null));
    e(this, "refresh", this._refresh.bind(this));
    e(this, "subscribe", this._watchlist.subscribe);
    this._watchlist.on.resume = () => {
      const s = [
        this._sessionContext.on(m, () => {
          this._canSkipSessionRefresh = !1, this._onAuthStateChanged();
        }),
        this._sessionContext.on(C, () => {
          this._refresh(this._canSkipSessionRefresh = !0);
        })
      ];
      this._watchlist.on.idle = () => {
        this._watchlist.on.idle = void 0, s.forEach((t) => t()), s.length = 0;
      }, !this.context.refreshing && x(this.context.isExpired) && this._refresh();
    };
  }
  get context() {
    return this._watchlist.snapshot;
  }
  set loadingContext(s) {
    this._setupContext.loadingContext = s;
  }
  set errorHandler(s) {
    this._specification.errorHandler = s;
  }
  set onSessionCreate(s) {
    this._specification.onSessionCreate !== s && (this._specification.onSessionCreate = s, this._refreshPromisorSignal && g(this._specification.onSessionCreate) && (this._canSkipSessionRefresh = !1, this._refresh()));
  }
  _onAuthStateChanged() {
    this._watchlist.requestNotification();
  }
  _refresh(s = !1) {
    this._refreshPromisor(s);
  }
}
export {
  y as AuthSession,
  y as default
};
